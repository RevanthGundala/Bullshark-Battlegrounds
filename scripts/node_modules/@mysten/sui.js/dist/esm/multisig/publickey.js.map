{
  "version": 3,
  "sources": ["../../../src/multisig/publickey.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { PublicKey, bytesEqual } from '../cryptography/publickey.js';\nimport type {\n\tSerializedSignature,\n\tSignatureFlag,\n\tSignatureScheme,\n} from '../cryptography/signature.js';\nimport {\n\tSIGNATURE_FLAG_TO_SCHEME,\n\tSIGNATURE_SCHEME_TO_FLAG,\n\tparseSerializedSignature,\n} from '../cryptography/signature.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { builder } from '../builder/bcs.js';\n// eslint-disable-next-line import/no-cycle\nimport { publicKeyFromRawBytes } from '../verify/index.js';\n\ntype CompressedSignature =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] };\n\ntype PublicKeyEnum = { ED25519: number[] } | { Secp256k1: number[] } | { Secp256r1: number[] };\n\ntype PubkeyEnumWeightPair = {\n\tpubKey: PublicKeyEnum;\n\tweight: number;\n};\n\ntype MultiSigPublicKeyStruct = {\n\tpk_map: PubkeyEnumWeightPair[];\n\tthreshold: number;\n};\n\nexport type MultiSigStruct = {\n\tsigs: CompressedSignature[];\n\tbitmap: number;\n\tmultisig_pk: MultiSigPublicKeyStruct;\n};\n\ntype ParsedPartialMultiSigSignature = {\n\tsignatureScheme: SignatureScheme;\n\tsignature: Uint8Array;\n\tpublicKey: PublicKey;\n\tweight: number;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\n\n/**\n * A MultiSig public key\n */\nexport class MultiSigPublicKey extends PublicKey {\n\tprivate rawBytes: Uint8Array;\n\tprivate multisigPublicKey: MultiSigPublicKeyStruct;\n\tprivate publicKeys: {\n\t\tweight: number;\n\t\tpublicKey: PublicKey;\n\t}[];\n\t/**\n\t * Create a new MultiSigPublicKey object\n\t */\n\tconstructor(\n\t\t/**\n\t\t *  MultiSig public key as buffer or base-64 encoded string\n\t\t */\n\t\tvalue: string | Uint8Array | MultiSigPublicKeyStruct,\n\t) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.rawBytes = fromB64(value);\n\t\t\tthis.multisigPublicKey = builder.de('MultiSigPublicKey', this.rawBytes);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.rawBytes = value;\n\t\t\tthis.multisigPublicKey = builder.de('MultiSigPublicKey', this.rawBytes);\n\t\t} else {\n\t\t\tthis.multisigPublicKey = value;\n\t\t\tthis.rawBytes = builder.ser('MultiSigPublicKey', value).toBytes();\n\t\t}\n\n\t\tthis.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {\n\t\t\tconst [scheme, bytes] = Object.entries(pubKey)[0] as [SignatureScheme, number[]];\n\t\t\treturn {\n\t\t\t\tpublicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes)),\n\t\t\t\tweight,\n\t\t\t};\n\t\t});\n\n\t\tif (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t\t}\n\t}\n\n\tstatic fromPublicKeys({\n\t\tthreshold,\n\t\tpublicKeys,\n\t}: {\n\t\tthreshold: number;\n\t\tpublicKeys: { publicKey: PublicKey; weight: number }[];\n\t}) {\n\t\treturn new MultiSigPublicKey({\n\t\t\tpk_map: publicKeys.map(({ publicKey, weight }) => {\n\t\t\t\tconst scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag() as SignatureFlag];\n\n\t\t\t\treturn {\n\t\t\t\t\tpubKey: { [scheme]: Array.from(publicKey.toRawBytes()) } as PublicKeyEnum,\n\t\t\t\t\tweight,\n\t\t\t\t};\n\t\t\t}),\n\t\t\tthreshold,\n\t\t});\n\t}\n\n\t/**\n\t * Checks if two MultiSig public keys are equal\n\t */\n\toverride equals(publicKey: MultiSigPublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the MultiSig public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.rawBytes;\n\t}\n\n\tgetPublicKeys() {\n\t\treturn this.publicKeys;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\toverride toSuiAddress(): string {\n\t\t// max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n\t\tconst maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n\t\tconst tmp = new Uint8Array(maxLength);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n\t\ttmp.set(builder.ser('u16', this.multisigPublicKey.threshold).toBytes(), 1);\n\t\tlet i = 3;\n\t\tfor (const { publicKey, weight } of this.publicKeys) {\n\t\t\tconst bytes = publicKey.toSuiBytes();\n\t\t\ttmp.set(bytes, i);\n\t\t\ti += bytes.length;\n\t\t\ttmp.set([weight], i++);\n\t\t}\n\t\treturn normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['MultiSig'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(\n\t\tmessage: Uint8Array,\n\t\tmultisigSignature: Uint8Array | SerializedSignature,\n\t): Promise<boolean> {\n\t\tif (typeof multisigSignature !== 'string') {\n\t\t\tthrow new Error('Multisig verification only supports serialized signature');\n\t\t}\n\n\t\tconst { signatureScheme, multisig } = parseSerializedSignature(multisigSignature);\n\n\t\tif (signatureScheme !== 'MultiSig') {\n\t\t\tthrow new Error('Invalid signature scheme');\n\t\t}\n\n\t\tlet signatureWeight = 0;\n\n\t\tif (\n\t\t\t!bytesEqual(\n\t\t\t\tbuilder.ser('MultiSigPublicKey', this.multisigPublicKey).toBytes(),\n\t\t\t\tbuilder.ser('MultiSigPublicKey', multisig.multisig_pk).toBytes(),\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {\n\t\t\tif (!(await publicKey.verify(message, signature))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsignatureWeight += weight;\n\t\t}\n\n\t\treturn signatureWeight >= this.multisigPublicKey.threshold;\n\t}\n\n\tcombinePartialSignatures(signatures: SerializedSignature[]): SerializedSignature {\n\t\tlet bitmap = 0;\n\t\tconst compressedSignatures: CompressedSignature[] = new Array(signatures.length);\n\n\t\tfor (let i = 0; i < signatures.length; i++) {\n\t\t\tlet parsed = parseSerializedSignature(signatures[i]);\n\n\t\t\tif (parsed.signatureScheme === 'MultiSig') {\n\t\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t\t}\n\n\t\t\tlet bytes = Array.from(parsed.signature.map((x) => Number(x)));\n\n\t\t\tif (parsed.signatureScheme === 'ED25519') {\n\t\t\t\tcompressedSignatures[i] = { ED25519: bytes };\n\t\t\t} else if (parsed.signatureScheme === 'Secp256k1') {\n\t\t\t\tcompressedSignatures[i] = { Secp256k1: bytes };\n\t\t\t} else if (parsed.signatureScheme === 'Secp256r1') {\n\t\t\t\tcompressedSignatures[i] = { Secp256r1: bytes };\n\t\t\t}\n\n\t\t\tlet publicKeyIndex;\n\t\t\tfor (let j = 0; j < this.publicKeys.length; j++) {\n\t\t\t\tif (bytesEqual(parsed.publicKey, this.publicKeys[j].publicKey.toRawBytes())) {\n\t\t\t\t\tif (bitmap & (1 << j)) {\n\t\t\t\t\t\tthrow new Error('Received multiple signatures from the same public key');\n\t\t\t\t\t}\n\n\t\t\t\t\tpublicKeyIndex = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (publicKeyIndex === undefined) {\n\t\t\t\tthrow new Error('Received signature from unknown public key');\n\t\t\t}\n\n\t\t\tbitmap |= 1 << publicKeyIndex;\n\t\t}\n\n\t\tlet multisig: MultiSigStruct = {\n\t\t\tsigs: compressedSignatures,\n\t\t\tbitmap,\n\t\t\tmultisig_pk: this.multisigPublicKey,\n\t\t};\n\n\t\tconst bytes = builder.ser('MultiSig', multisig).toBytes();\n\t\tlet tmp = new Uint8Array(bytes.length + 1);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\t\ttmp.set(bytes, 1);\n\t\treturn toB64(tmp);\n\t}\n}\n\nexport function parsePartialSignatures(multisig: MultiSigStruct): ParsedPartialMultiSigSignature[] {\n\tlet res: ParsedPartialMultiSigSignature[] = new Array(multisig.sigs.length);\n\tfor (let i = 0; i < multisig.sigs.length; i++) {\n\t\tconst [signatureScheme, signature] = Object.entries(multisig.sigs[i])[0] as [\n\t\t\tSignatureScheme,\n\t\t\tnumber[],\n\t\t];\n\t\tconst pkIndex = asIndices(multisig.bitmap).at(i)!;\n\t\tconst pair = multisig.multisig_pk.pk_map[pkIndex];\n\t\tconst pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);\n\n\t\tif (signatureScheme === 'MultiSig') {\n\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t}\n\n\t\tconst publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes);\n\n\t\tres[i] = {\n\t\t\tsignatureScheme,\n\t\t\tsignature: Uint8Array.from(signature),\n\t\t\tpublicKey: publicKey,\n\t\t\tweight: pair.weight,\n\t\t};\n\t}\n\treturn res;\n}\n\nfunction asIndices(bitmap: number): Uint8Array {\n\tif (bitmap < 0 || bitmap > 1024) {\n\t\tthrow new Error('Invalid bitmap');\n\t}\n\tlet res: number[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tif ((bitmap & (1 << i)) !== 0) {\n\t\t\tres.push(i);\n\t\t}\n\t}\n\treturn Uint8Array.from(res);\n}\n"],
  "mappings": "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",
  "names": ["bytes"]
}
