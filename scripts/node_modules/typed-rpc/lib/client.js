"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTransport = exports.removeTrailingUndefs = exports.createRequest = exports.rpcClient = exports.RpcError = void 0;
/**
 * Error class that is thrown if a remote method returns an error.
 */
class RpcError extends Error {
    constructor(message, code, data) {
        super(message);
        this.code = code;
        this.data = data;
        // https://www.typescriptlang.org/docs/handbook/2/classes.html#inheriting-built-in-types
        Object.setPrototypeOf(this, RpcError.prototype);
    }
}
exports.RpcError = RpcError;
function rpcClient(options) {
    if (typeof options === "string") {
        options = { url: options };
    }
    const transport = "transport" in options ? options.transport : fetchTransport(options);
    return new Proxy({}, {
        /* istanbul ignore next */
        get(target, prop, receiver) {
            if (typeof prop === "symbol")
                return;
            if (prop.startsWith("$"))
                return;
            if (prop in Object.prototype)
                return;
            if (prop === "toJSON")
                return;
            return async (...args) => {
                const res = await transport(createRequest(prop.toString(), args));
                if ("result" in res) {
                    return res.result;
                }
                else if ("error" in res) {
                    const { code, message, data } = res.error;
                    throw new RpcError(message, code, data);
                }
                throw new TypeError("Invalid response");
            };
        },
    });
}
exports.rpcClient = rpcClient;
/**
 * Create a JsonRpcRequest for the given method.
 */
function createRequest(method, params) {
    return {
        jsonrpc: "2.0",
        id: Date.now(),
        method,
        params: removeTrailingUndefs(params),
    };
}
exports.createRequest = createRequest;
/**
 * Returns a shallow copy the given array without any
 * trailing `undefined` values.
 */
function removeTrailingUndefs(values) {
    const a = [...values];
    while (a.length && a[a.length - 1] === undefined)
        a.length--;
    return a;
}
exports.removeTrailingUndefs = removeTrailingUndefs;
/**
 * Create a RpcTransport that uses the global fetch.
 */
function fetchTransport(options) {
    return async (req) => {
        const headers = options?.getHeaders ? await options.getHeaders() : {};
        const res = await fetch(options.url, {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                ...headers,
            },
            body: JSON.stringify(req),
            credentials: options?.credentials,
        });
        if (!res.ok) {
            throw new RpcError(res.statusText, res.status);
        }
        return await res.json();
    };
}
exports.fetchTransport = fetchTransport;
//# sourceMappingURL=client.js.map